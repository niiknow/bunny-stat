sources:
  bunny_src:
    type: syslog
    address: '0.0.0.0:6514'
    mode: udp

sinks:
  bunny_file_sink:
    type: file
    inputs:
      - bunny_transform
    compression: none
    path: /logs/bunny_log-%Y-%m-%d.log
    encoding:
      codec: raw_message

  bunny_search_sink:
    type: http
    inputs:
      - bunny_shaker
    uri: 'http://openobserve:5080/api/default/bunny_log/_json'
    method: post
    auth:
      strategy: basic
      user: "${SEARCH_EMAIL:?search email is required}"
      password: "${SEARCH_PWD:?search pwd is required}"
    compression: gzip
    batch:
      timeout_secs: 10
    encoding:
      codec: json
      #timestamp_format: rfc3339
    healthcheck:
      enabled: false

  bunny_metric_exporter:
    type: prometheus_exporter
    inputs:
      - bunny_metric
    default_namespace: bunny
    # address: 0.0.0.0:9598 # this is already default

  # alternate to bunny_metric_exporter above
  # bunny_metric_sink:
  #   type: prometheus_remote_write
  #   inputs:
  #     - bunny_metric
  #   endpoint: "http://prometheus:9090/api/v1/write"
  #   default_namespace: bunny
  #   auth:
  #     strategy: basic
  #     user: "${PROM_USER:?prometheus user is required}"
  #     password: "${PROM_PWD:?prometheus pwd is required}"
  #  compression: gzip
  #  batch:
  #    timeout_secs: 10

transforms:
  # optionally verify bunnycdn token/password
  # password going to come in as the event object key: OptionalBunnyToken@workerid
  bunny_prefilter:
    type: filter
    inputs:
      - bunny_src
    condition: 'starts_with(string!(keys(.)[0]), "OptionalBunnyToken@")'

  # parse log PathAndQuery for /shake aka tree shaking
  # to get event Action(ea), Category (ec), and Value (ev)
  bunny_transform:
    type: remap
    inputs:
      - bunny_prefilter
    source: |
      .request_type = ""

      # BunnyCDN sends BOM character so make sure to strip or fail parse_json
      msg2 = strip_whitespace(string!(.message) || "")
      msg2 = replace(msg2, r'[\uFEFF-\uFFFF]', "")
      msg = parse_json!(msg2)
      pnq = string!(msg.PathAndQuery || "/")
      if (starts_with(pnq, "/shake")) {
        # log(pnq)
        uri = "http://x{{ pnq }}"
        parts = parse_url!(uri)
        msg.query = parts.query
        path = replace(replace(downcase!(parts.path), r'[^a-z0-9-/\?]+', "-"), r'-+', "-")
        paths = split(path, "/")
        msg.ec = paths[2] || ""
        msg.ea = paths[3] || ""
        msg.el = paths[4] || ""
        msg.ev = 1

        if (match!(parts.query.ev || "", r'^[0-9]+$')) {
          msg.ev = parse_int!(parts.query.ev)
        }
        .request_type = "shaker"
      }
      del(.message)

      ts = msg.Timestamp
      del(msg.Timestamp)
      msg._timestamp = ts
      msg.timestamp = from_unix_timestamp!(ts, unit: "milliseconds")
      .message = msg

  bunny_shaker:
    type: filter
    inputs:
      - bunny_transform
    condition: .request_type == "shaker"

  bunny_metric:
    type: log_to_metric
    inputs:
      - bunny_shaker
    metrics:
      - type: counter
        field: message.ev
        name: "event_{{ message.ec }}"
        namespace: bunny
        _timestamp: message._timestamp
        tags:
          action: "{{ message.ea }}"
          label: "{{ message.el }}"
          value: "{{ message.ev }}"
