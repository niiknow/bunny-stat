sources:
  bunny_src:
    type: syslog
    address: '0.0.0.0:6514'
    mode: udp

sinks:
  bunny_file_sink:
    type: file
    inputs:
      - bunny_transform
    compression: none
    path: /logs/bunny_log-%Y-%m-%d.log
    encoding:
      codec: raw_message

  bunny_search_sink:
    type: http
    inputs:
      - bunny_shaker
    uri: 'http://openobserve:5080/api/default/bunny_log/_json'
    method: post
    auth:
      strategy: basic
      user: "${SEARCH_EMAIL:?search email is required}"
      password: "${SEARCH_PWD:?search pwd is required}"
    compression: gzip
    encoding:
      codec: json
      #timestamp_format: rfc3339
    healthcheck:
      enabled: false

  bunny_metric_sink:
    type: prometheus_remote_write
    inputs:
      - bunny_metric
    endpoint: "http://prometheus:9090/api/v1/write"
    default_namespace: "bunny"
    auth:
      strategy: basic
      user: "${PROM_USER:?prometheus user is required}"
      password: "${PROM_PWD:?prometheus pwd is required}"

transforms:
  # optionally verify bunnycdn token/password
  # password going to come in as the event object key: OptionalBunnyToken@workerid
  bunny_prefilter:
    type: filter
    inputs:
      - bunny_src
    condition: 'starts_with(string!(keys(.)[0]), "OptionalBunnyToken@")'

  # parse log PathAndQuery for /shake aka tree shaking
  # to get event Action(ea), Category (ec), and Value (ev)
  bunny_transform:
    type: remap
    inputs:
      - bunny_prefilter
    source: |
      .request_type = ""

      # BunnyCDN sends BOM character so make sure to strip or fail parse_json
      msg2 = strip_whitespace(string!(.message) || "")
      msg2 = replace(msg2, r'[\uFEFF-\uFFFF]', "")
      msg = parse_json!(msg2)
      pnq = string!(msg.PathAndQuery || "/")
      if (starts_with(pnq, "/shake")) {
        # log(pnq)
        uri = "http://x{{ pnq }}"
        parts = parse_url!(uri)
        msg.query = parts.query
        path = replace(replace(downcase!(parts.path), r'[^a-z0-9-/\?]+', "-"), r'-+', "-")
        paths = split(path, "/")
        msg.ec = paths[2] || ""
        msg.ea = paths[3] || ""
        msg.el = paths[4] || ""
        msg.ev = 1

        if (match!(parts.query.ev || "", r'^[0-9]+$')) {
          msg.ev = parse_int!(parts.query.ev)
        }
        .request_type = "shaker"
      }
      del(.message)
      msg._timestamp = msg.Timestamp
      msg.Timestamp = from_unix_timestamp!(msg.Timestamp, unit: "milliseconds")
      .message = msg

  bunny_shaker:
    type: filter
    inputs:
      - bunny_transform
    condition: .request_type == "shaker"

  bunny_metric:
    type: log_to_metric
    inputs:
      - bunny_shaker
    metrics:
      - type: counter
        field: message.ev
        name: "event_{{ message.ec }}"
        tags:
          action: "{{ message.ea }}"
          label: "{{ message.el }}"
          value: "{{ message.ev }}"
